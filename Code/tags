!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.6	//
ADD	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
ADDRESS	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC} kind;$/;"	e	enum:Operand_::__anon4
ADD_ASSIGN	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
ARG	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
ARRAY	Seman.h	/^	enum{BASIC , ARRAY , STRUCT} kind;$/;"	e	enum:Type_::__anon1
ASSIGN	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
ASSIGN_REF	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
Args	syntax.y	/^Args : Exp COMMA Args {$$ = creat_node(3 , "Exp" , &@$ ,  $1 , $2 , $3);}	$/;"	l
BASIC	Seman.h	/^	enum{BASIC , ARRAY , STRUCT} kind;$/;"	e	enum:Type_::__anon1
BISON	Makefile	/^BISON = bison$/;"	m
Bool	Seman.h	/^enum Bool {FALSE , TRUE};$/;"	g
CALLFUNC	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
CC	Makefile	/^CC = gcc$/;"	m
CFILES	Makefile	/^CFILES = $(shell find .\/ -name "*.c")$/;"	m
CFLAGS	Makefile	/^CFLAGS = -std=c99$/;"	m
CONSTANT	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC} kind;$/;"	e	enum:Operand_::__anon4
CharactInfoEntry_Func	FuncTable.h	/^struct CharactInfoEntry_Func$/;"	s
CharactInfoEntry_Id	IdTable.h	/^struct CharactInfoEntry_Id$/;"	s
CharactInfoEntry_Struct	StructTable.h	/^struct CharactInfoEntry_Struct$/;"	s
CheckStructTable	StructTable.c	/^bool CheckStructTable(struct CharactInfoEntry_Struct* p)$/;"	f
CompSt	syntax.y	/^CompSt : LC DefList StmtList RC {$$ = creat_node(4 , "CompSt" , &@$ ,  $1 , $2 , $3 , $4);}$/;"	l
CurrentArgs	Seman.c	/^FieldList CurrentArgs(struct tree_node* p)\/\/Args-> Exp COMMA Args$/;"	f
CurrentCompSt	Seman.c	/^void CurrentCompSt(Type type , struct tree_node* p)\/\/CompSt -> LC DefList StmtList Rc$/;"	f
CurrentDec	Seman.c	/^FieldList CurrentDec(Type type , struct tree_node* p) $/;"	f
CurrentDecList	Seman.c	/^FieldList CurrentDecList(Type type , struct tree_node* p)$/;"	f
CurrentDecList_1	Seman.c	/^void CurrentDecList_1(Type type , struct tree_node* p)$/;"	f
CurrentDec_1	Seman.c	/^void CurrentDec_1(Type type , struct tree_node* p)$/;"	f
CurrentDef	Seman.c	/^FieldList CurrentDef(struct tree_node* p)$/;"	f
CurrentDefList	Seman.c	/^FieldList CurrentDefList(struct tree_node* p)$/;"	f
CurrentDefList_1	Seman.c	/^void CurrentDefList_1(struct tree_node* p)$/;"	f
CurrentDef_1	Seman.c	/^void CurrentDef_1(struct tree_node* p)$/;"	f
CurrentExp	Seman.c	/^Type CurrentExp(struct tree_node* p)$/;"	f
CurrentExtDecList	Seman.c	/^void CurrentExtDecList(Type inh , struct tree_node* p)$/;"	f
CurrentExtDef	Seman.c	/^void CurrentExtDef(struct tree_node* p)$/;"	f
CurrentExtDefList	Seman.c	/^void CurrentExtDefList(struct tree_node* p)$/;"	f
CurrentFunDec	Seman.c	/^int CurrentFunDec(Type inh ,struct tree_node* p)$/;"	f
CurrentOptTag	Seman.c	/^char* CurrentOptTag(struct tree_node* p)$/;"	f
CurrentParamDec	Seman.c	/^Type CurrentParamDec(struct tree_node* p)$/;"	f
CurrentProgram	Seman.c	/^void CurrentProgram(struct tree_node* p)$/;"	f
CurrentReturnExp	Seman.c	/^void CurrentReturnExp(Type return_type , struct tree_node* p)$/;"	f
CurrentSpecifier	Seman.c	/^Type CurrentSpecifier(struct tree_node* p)$/;"	f
CurrentStmt	Seman.c	/^void CurrentStmt(Type type , struct tree_node* p)$/;"	f
CurrentStmtList	Seman.c	/^void CurrentStmtList(Type type , struct tree_node* p)$/;"	f
CurrentStructSpecifier	Seman.c	/^Type CurrentStructSpecifier(struct tree_node* p)$/;"	f
CurrentTag	Seman.c	/^char* CurrentTag(struct tree_node* p)$/;"	f
CurrentVarDec	Seman.c	/^FieldList CurrentVarDec(Type inh , struct tree_node* p)$/;"	f
CurrentVarDec_1	Seman.c	/^FieldList CurrentVarDec_1(Type inh , struct tree_node* p)$/;"	f
CurrentVarList	Seman.c	/^FieldList CurrentVarList(struct tree_node* p , int* para_amount)$/;"	f
DEC	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
DIV	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
Dec	syntax.y	/^Dec : VarDec {$$ = creat_node(1 , "Dec" , &@$ ,  $1);}$/;"	l
DecList	syntax.y	/^DecList : Dec {$$ = creat_node(1 , "DecList" , &@$ , $1);}$/;"	l
Def	syntax.y	/^Def : Specifier DecList SEMI {$$ = creat_node(3 , "Def" , &@$ ,  $1 , $2 , $3);}$/;"	l
DefList	syntax.y	/^DefList : Def DefList {$$ = creat_node(2 , "DefList" , &@$ ,  $1 , $2);}$/;"	l
Exp	syntax.y	/^Exp : Exp ASSIGNOP Exp {$$ = creat_node(3 , "Exp" , &@$ ,  $1 , $2 , $3);}$/;"	l
ExtDecList	syntax.y	/^ExtDecList : VarDec {$$ = creat_node(1 , "ExtDecList" , &@$ ,  $1);}$/;"	l
ExtDef	syntax.y	/^ExtDef : Specifier ExtDecList SEMI {$$ = creat_node(3 , "ExtDef" , &@$ ,  $1 , $2 , $3);}$/;"	l
ExtDefList	syntax.y	/^ExtDefList : ExtDef ExtDefList {$$ = creat_node(2 , "ExtDefList" , &@$ ,  $1 , $2);}$/;"	l
FALSE	Seman.h	/^enum Bool {FALSE , TRUE};$/;"	e	enum:Bool
FLEX	Makefile	/^FLEX = flex$/;"	m
FUNC	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC} kind;$/;"	e	enum:Operand_::__anon4
FUNCTION	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
FieldList	Seman.h	/^typedef struct FieldList_* FieldList;$/;"	t	typeref:struct:FieldList_
FieldList_	Seman.h	/^struct FieldList_$/;"	s
FindFunc	FuncTable.c	/^int FindFunc(char* name)$/;"	f
FindId	IdTable.c	/^Type FindId(char* name)$/;"	f
FindStruct	StructTable.c	/^FieldList FindStruct(char* name)$/;"	f
FunDec	syntax.y	/^FunDec : ID LP VarList RP {$$ = creat_node(4 , "FunDec" , &@$ ,  $1 , $2 , $3 , $4);}$/;"	l
FuncTable	FuncTable.h	/^struct CharactInfoEntry_Func FuncTable[10];$/;"	v	typeref:struct:CharactInfoEntry_Func
GOTO	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
IdTable	IdTable.h	/^struct CharactInfoEntry_Id IdTable[100];$/;"	v	typeref:struct:CharactInfoEntry_Id
Id_name	IdTable.h	/^	char* Id_name;$/;"	m	struct:CharactInfoEntry_Id
InterCode	translate.h	/^struct InterCode$/;"	s
InterCodes	translate.h	/^struct InterCodes$/;"	s
IsHomoStruct	StructTable.c	/^bool IsHomoStruct(FieldList target , FieldList origin)$/;"	f
IsHomoType	StructTable.c	/^bool IsHomoType(Type target , Type origin)$/;"	f
IsLeft	Seman.c	/^bool IsLeft(struct tree_node* p)$/;"	f
IsSameFuncName	FuncTable.c	/^bool IsSameFuncName(char* name)$/;"	f
IsSameInStruct	StructTable.c	/^bool IsSameInStruct(FieldList origin , char* name)$/;"	f
IsSameName	Seman.c	/^bool IsSameName(char* name)$/;"	f
IsSameNameInField	Seman.c	/^bool IsSameNameInField(FieldList field , char* name)$/;"	f
IsSameNameInStructure	Seman.c	/^void IsSameNameInStructure(FieldList field)$/;"	f
IsSameStructure	Seman.c	/^bool IsSameStructure(FieldList target , FieldList origin)$/;"	f
IsSameType	Seman.c	/^bool IsSameType(Type target , Type origin)$/;"	f
LABEL	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
LABEL_SIGN	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC} kind;$/;"	e	enum:Operand_::__anon4
LFC	Makefile	/^LFC = $(shell find .\/ -name "*.l" | sed s\/[^\/]*\\\\.l\/lex.yy.c\/)$/;"	m
LFILE	Makefile	/^LFILE = $(shell find .\/ -name "*.l")$/;"	m
LFO	Makefile	/^LFO = $(LFC:.c=.o)$/;"	m
MUL	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
OBJS	Makefile	/^OBJS = $(CFILES:.c=.o)$/;"	m
Operand	translate.h	/^typedef struct Operand_* Operand;$/;"	t	typeref:struct:Operand_
Operand_	translate.h	/^struct Operand_$/;"	s
OptTag	syntax.y	/^OptTag : ID {$$ = creat_node(1 , "OptTag" , &@$ ,  $1);}$/;"	l
PARAM	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
ParamDec	syntax.y	/^ParamDec : Specifier VarDec {$$ = creat_node(2 , "ParamDec" , &@$ ,  $1 , $2);}$/;"	l
Program	syntax.y	/^Program : ExtDefList {$$ = creat_node(1 , "Program" , &@$ ,  $1); root = $$;}$/;"	l
READ	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
REF_ASSIGN	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
RELOP_GOTO	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
RETURN	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
STRUCT	Seman.h	/^	enum{BASIC , ARRAY , STRUCT} kind;$/;"	e	enum:Type_::__anon1
SUB	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
Seman_analysis	Seman.c	/^void Seman_analysis(struct tree_node* p)$/;"	f
Specifier	syntax.y	/^Specifier : TYPE {$$ = creat_node(1 , "Specifier" , &@$ ,  $1);}$/;"	l
Stmt	syntax.y	/^Stmt : Exp SEMI {$$ = creat_node(2 , "Stmt" , &@$ ,  $1 , $2);}$/;"	l
StmtList	syntax.y	/^StmtList : Stmt StmtList {$$ = creat_node(2 , "StmtList" , &@$ ,  $1 , $2);}$/;"	l
StructSpecifier	syntax.y	/^StructSpecifier : STRUCT OptTag LC DefList RC {$$ = creat_node(5 , "StructSpecifier" , &@$ ,  $1 , $2 , $3 , $4 , $5);}$/;"	l
StructTable	StructTable.h	/^struct CharactInfoEntry_Struct StructTable[100];$/;"	v	typeref:struct:CharactInfoEntry_Struct
Struct_name	StructTable.h	/^	char* Struct_name;$/;"	m	struct:CharactInfoEntry_Struct
TEMP	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC} kind;$/;"	e	enum:Operand_::__anon4
TRUE	Seman.h	/^enum Bool {FALSE , TRUE};$/;"	e	enum:Bool
Tag	syntax.y	/^Tag : ID {$$ = creat_node(1 , "Tag" , &@$ ,  $1);}$/;"	l
Type	Seman.h	/^typedef struct Type_* Type;$/;"	t	typeref:struct:Type_
Type_	Seman.h	/^struct Type_$/;"	s
VARIABLE	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC} kind;$/;"	e	enum:Operand_::__anon4
VarDec	syntax.y	/^VarDec : ID {$$ = creat_node(1 , "VarDec" , &@$ ,  $1);}$/;"	l
VarList	syntax.y	/^VarList : ParamDec COMMA VarList {$$ = creat_node(3 , "VarList" , &@$ ,  $1 , $2 , $3);}$/;"	l
WRITE	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
WriteFuncTable	FuncTable.c	/^int WriteFuncTable(char* name , Type return_type , int para_amount , FieldList parameter)$/;"	f
WriteIdTable	IdTable.c	/^void WriteIdTable(Type inh , char* name)$/;"	f
WriteStructTable	StructTable.c	/^void WriteStructTable(FieldList p , char* name)$/;"	f
YFC	Makefile	/^YFC = $(shell find .\/ -name "*.y" | sed s\/[^\/]*\\\\.y\/syntax.tab.c\/)$/;"	m
YFILE	Makefile	/^YFILE = $(shell find .\/ -name "*.y")$/;"	m
YFO	Makefile	/^YFO = $(YFC:.c=.o)$/;"	m
__COMMON__	common.h	6;"	d
__FUNC__	FuncTable.h	4;"	d
__ID__	IdTable.h	4;"	d
__SEMAN__	Seman.h	2;"	d
__STRUCT__	StructTable.h	3;"	d
__TRAN__	translate.h	2;"	d
alop	translate.h	/^		struct {Operand x, y, z;} alop;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon10
arg	translate.h	/^		struct {Operand x;} arg;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon16
array	Seman.h	/^		struct{Type elem; int size;}array;$/;"	m	union:Type_::__anon2	typeref:struct:Type_::__anon2::__anon3
assignop	translate.h	/^		struct {Operand x , y;} assignop;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon11
basic	Seman.h	/^		int basic;\/\/if Int basic = 0 , if Float basic = 1$/;"	m	union:Type_::__anon2
bool	Seman.h	/^typedef enum Bool bool;$/;"	t	typeref:enum:Bool
callfunc	translate.h	/^		struct {Operand x , f;} callfunc;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon17
children	common.h	/^	struct tree_node** children;$/;"	m	struct:tree_node	typeref:struct:tree_node::tree_node
children_num	common.h	/^	unsigned int children_num;$/;"	m	struct:tree_node
code	translate.h	/^	struct InterCode code;$/;"	m	struct:InterCodes	typeref:struct:InterCodes::InterCode
code_head	translate.h	/^struct InterCodes* code_head;$/;"	v	typeref:struct:InterCodes
creat_node	main.c	/^struct tree_node* creat_node(int arity , char* token_name , struct YYLTYPE* current_pos, ...)$/;"	f
current_code	translate.h	/^struct InterCodes* current_code;$/;"	v	typeref:struct:InterCodes
dec	translate.h	/^		struct {Operand x ,  size;} dec;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon15
display_float	main.c	/^void display_float(char* p)$/;"	f
display_tree	main.c	/^void display_tree(struct tree_node* p , int count)$/;"	f
distroy_tree	main.c	/^void distroy_tree(struct tree_node* p )$/;"	f
elem	Seman.h	/^		struct{Type elem; int size;}array;$/;"	m	struct:Type_::__anon2::__anon3
entry	StructTable.h	/^	FieldList entry;$/;"	m	struct:CharactInfoEntry_Struct
f	translate.h	/^		struct {Operand f;} function;$/;"	m	struct:InterCode::__anon7::__anon9
f	translate.h	/^		struct {Operand x , f;} callfunc;$/;"	m	struct:InterCode::__anon7::__anon17
func_name	FuncTable.h	/^	char* func_name;$/;"	m	struct:CharactInfoEntry_Func
func_name	translate.h	/^		char* func_name;$/;"	m	union:Operand_::__anon5
function	translate.h	/^		struct {Operand f;} function;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon9
gotolabel	translate.h	/^		struct {Operand x;} gotolabel;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon12
initial_InterCodes	translate.c	/^void initial_InterCodes()$/;"	f
insertcode	translate.c	/^void insertcode(struct InterCodes* new_code)$/;"	f
kind	Seman.h	/^	enum{BASIC , ARRAY , STRUCT} kind;$/;"	m	struct:Type_	typeref:enum:Type_::__anon1
kind	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN ,DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	m	struct:InterCode	typeref:enum:InterCode::__anon6
kind	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC} kind;$/;"	m	struct:Operand_	typeref:enum:Operand_::__anon4
label	translate.h	/^		struct {Operand x;} label;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon8
label_no	translate.h	/^		int label_no;$/;"	m	union:Operand_::__anon5
label_num	translate.h	/^int label_num;$/;"	v
lineno	Seman.h	/^	int lineno;$/;"	m	struct:FieldList_
lineno	common.h	/^	int lineno;$/;"	m	struct:tree_node
lookup	IdTable.c	/^int lookup(char* name)$/;"	f
main	main.c	/^int main(int argc , char** argv)$/;"	f
name	Seman.h	/^	char* name;$/;"	m	struct:FieldList_
next	Seman.h	/^	FieldList next;$/;"	m	struct:FieldList_
next	translate.h	/^	struct InterCodes* next;$/;"	m	struct:InterCodes	typeref:struct:InterCodes::InterCodes
out_file	translate.c	6;"	d	file:
outputInterCode	translate.c	/^void outputInterCode()$/;"	f
outputalop	translate.c	/^void outputalop(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputarg	translate.c	/^void outputarg(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputassign	translate.c	/^void outputassign(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputcallfunc	translate.c	/^void outputcallfunc(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputdec	translate.c	/^void outputdec(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputfunction	translate.c	/^void outputfunction(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputgoto	translate.c	/^void outputgoto(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputlabel	translate.c	/^void outputlabel(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputoperand	translate.c	/^void outputoperand(Operand op , FILE* des)$/;"	f
outputparam	translate.c	/^void outputparam(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputread	translate.c	/^void outputread(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputrelopgoto	translate.c	/^void outputrelopgoto(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputreturn	translate.c	/^void outputreturn(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputwrite	translate.c	/^void outputwrite(struct InterCodes* intercode_p , FILE* des)$/;"	f
para_amount	FuncTable.h	/^	int para_amount;$/;"	m	struct:CharactInfoEntry_Func
param	translate.h	/^		struct {Operand x;} param;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon18
parameter	FuncTable.h	/^	FieldList parameter;$/;"	m	struct:CharactInfoEntry_Func
pre_occupy_func	translate.c	/^void pre_occupy_func()$/;"	f
prev	translate.h	/^	struct InterCodes* prev;$/;"	m	struct:InterCodes	typeref:struct:InterCodes::InterCodes
read	translate.h	/^		struct {Operand x;} read;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon19
relop	translate.h	/^		struct {Operand x, y, z , relop;} relopgoto;$/;"	m	struct:InterCode::__anon7::__anon13
relopgoto	translate.h	/^		struct {Operand x, y, z , relop;} relopgoto;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon13
ret	translate.h	/^		struct {Operand x;} ret;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon14
return_type	FuncTable.h	/^	Type return_type;$/;"	m	struct:CharactInfoEntry_Func
root	main.c	/^struct tree_node* root;$/;"	v	typeref:struct:tree_node
size	Seman.h	/^		struct{Type elem; int size;}array;$/;"	m	struct:Type_::__anon2::__anon3
size	translate.h	/^		struct {Operand x ,  size;} dec;$/;"	m	struct:InterCode::__anon7::__anon15
structure	Seman.h	/^		FieldList structure;$/;"	m	union:Type_::__anon2
temp_no	translate.h	/^		int temp_no;$/;"	m	union:Operand_::__anon5
temp_num	translate.h	/^int temp_num;$/;"	v
token_name	common.h	/^	char* token_name;$/;"	m	struct:tree_node
translate	translate.c	/^void translate(struct tree_node* p)$/;"	f
translate_cond	translate.c	/^void translate_cond(struct tree_node* p , Operand label1 , Operand label2)$/;"	f
translate_exp	translate.c	/^void translate_exp(struct tree_node* p , Operand place)$/;"	f
translate_function	translate.c	/^void translate_function(struct tree_node* p)$/;"	f
translate_stmt	translate.c	/^void translate_stmt(struct tree_node* p)$/;"	f
tree_node	common.h	/^struct tree_node$/;"	s
type	IdTable.h	/^	Type type;$/;"	m	struct:CharactInfoEntry_Id
type	Seman.h	/^	Type type;$/;"	m	struct:FieldList_
type	common.h	/^	int type;\/*1:INT FLOAT TYPE ID 2:lexical 3:bison*\/$/;"	m	struct:tree_node
u	Seman.h	/^	}u;$/;"	m	struct:Type_	typeref:union:Type_::__anon2
u	translate.h	/^	}u;$/;"	m	struct:InterCode	typeref:union:InterCode::__anon7
u	translate.h	/^	}u;$/;"	m	struct:Operand_	typeref:union:Operand_::__anon5
unit_name	common.h	/^	char* unit_name;$/;"	m	struct:tree_node
valid	FuncTable.h	/^	int valid;$/;"	m	struct:CharactInfoEntry_Func
valid	IdTable.h	/^	int valid;$/;"	m	struct:CharactInfoEntry_Id
valid	StructTable.h	/^	int valid;$/;"	m	struct:CharactInfoEntry_Struct
value	translate.h	/^		int value;$/;"	m	union:Operand_::__anon5
var_no	IdTable.h	/^	int var_no;$/;"	m	struct:CharactInfoEntry_Id
var_no	translate.h	/^		int var_no;$/;"	m	union:Operand_::__anon5
variable_num	translate.h	/^int variable_num;$/;"	v
write	translate.h	/^		struct {Operand x;} write;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon20
x	translate.h	/^		struct {Operand x ,  size;} dec;$/;"	m	struct:InterCode::__anon7::__anon15
x	translate.h	/^		struct {Operand x , f;} callfunc;$/;"	m	struct:InterCode::__anon7::__anon17
x	translate.h	/^		struct {Operand x , y;} assignop;$/;"	m	struct:InterCode::__anon7::__anon11
x	translate.h	/^		struct {Operand x, y, z , relop;} relopgoto;$/;"	m	struct:InterCode::__anon7::__anon13
x	translate.h	/^		struct {Operand x, y, z;} alop;$/;"	m	struct:InterCode::__anon7::__anon10
x	translate.h	/^		struct {Operand x;} arg;$/;"	m	struct:InterCode::__anon7::__anon16
x	translate.h	/^		struct {Operand x;} gotolabel;$/;"	m	struct:InterCode::__anon7::__anon12
x	translate.h	/^		struct {Operand x;} label;$/;"	m	struct:InterCode::__anon7::__anon8
x	translate.h	/^		struct {Operand x;} param;$/;"	m	struct:InterCode::__anon7::__anon18
x	translate.h	/^		struct {Operand x;} read;$/;"	m	struct:InterCode::__anon7::__anon19
x	translate.h	/^		struct {Operand x;} ret;$/;"	m	struct:InterCode::__anon7::__anon14
x	translate.h	/^		struct {Operand x;} write;$/;"	m	struct:InterCode::__anon7::__anon20
y	translate.h	/^		struct {Operand x , y;} assignop;$/;"	m	struct:InterCode::__anon7::__anon11
y	translate.h	/^		struct {Operand x, y, z , relop;} relopgoto;$/;"	m	struct:InterCode::__anon7::__anon13
y	translate.h	/^		struct {Operand x, y, z;} alop;$/;"	m	struct:InterCode::__anon7::__anon10
z	translate.h	/^		struct {Operand x, y, z , relop;} relopgoto;$/;"	m	struct:InterCode::__anon7::__anon13
z	translate.h	/^		struct {Operand x, y, z;} alop;$/;"	m	struct:InterCode::__anon7::__anon10
