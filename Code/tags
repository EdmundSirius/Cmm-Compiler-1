!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.6	//
ADD	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
ADDRESS	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC , RELOP , READ_ADDRESS} kind;$/;"	e	enum:Operand_::__anon4
ADD_ASSIGN	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
ARG	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
ARRAY	Seman.h	/^	enum{BASIC , ARRAY , STRUCT} kind;$/;"	e	enum:Type_::__anon1
ASSIGN	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
ASSIGN_REF	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
Arg	translate.h	/^struct Arg$/;"	s
Args	syntax.y	/^Args : Exp COMMA Args {$$ = creat_node(3 , "Exp" , &@$ ,  $1 , $2 , $3);}	$/;"	l
BASIC	Seman.h	/^	enum{BASIC , ARRAY , STRUCT} kind;$/;"	e	enum:Type_::__anon1
BISON	Makefile	/^BISON = bison$/;"	m
Bool	Seman.h	/^enum Bool {FALSE , TRUE};$/;"	g
CALLFUNC	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
CC	Makefile	/^CC = gcc$/;"	m
CFILES	Makefile	/^CFILES = $(shell find .\/ -name "*.c")$/;"	m
CFLAGS	Makefile	/^CFLAGS = -std=c99$/;"	m
CONSTANT	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC , RELOP , READ_ADDRESS} kind;$/;"	e	enum:Operand_::__anon4
CharactInfoEntry_Func	FuncTable.h	/^struct CharactInfoEntry_Func$/;"	s
CharactInfoEntry_Id	IdTable.h	/^struct CharactInfoEntry_Id$/;"	s
CharactInfoEntry_Struct	StructTable.h	/^struct CharactInfoEntry_Struct$/;"	s
CheckStructTable	StructTable.c	/^bool CheckStructTable(struct CharactInfoEntry_Struct* p)$/;"	f
Cnt	genasm.h	/^	int Cnt;$/;"	m	struct:Reg
CompSt	syntax.y	/^CompSt : LC DefList StmtList RC {$$ = creat_node(4 , "CompSt" , &@$ ,  $1 , $2 , $3 , $4);}$/;"	l
CurrentArgs	Seman.c	/^FieldList CurrentArgs(struct tree_node* p)\/\/Args-> Exp COMMA Args$/;"	f
CurrentCompSt	Seman.c	/^void CurrentCompSt(Type type , struct tree_node* p)\/\/CompSt -> LC DefList StmtList Rc$/;"	f
CurrentDec	Seman.c	/^FieldList CurrentDec(Type type , struct tree_node* p) $/;"	f
CurrentDecList	Seman.c	/^FieldList CurrentDecList(Type type , struct tree_node* p)$/;"	f
CurrentDecList_1	Seman.c	/^void CurrentDecList_1(Type type , struct tree_node* p)$/;"	f
CurrentDec_1	Seman.c	/^void CurrentDec_1(Type type , struct tree_node* p)$/;"	f
CurrentDef	Seman.c	/^FieldList CurrentDef(struct tree_node* p)$/;"	f
CurrentDefList	Seman.c	/^FieldList CurrentDefList(struct tree_node* p)$/;"	f
CurrentDefList_1	Seman.c	/^void CurrentDefList_1(struct tree_node* p)$/;"	f
CurrentDef_1	Seman.c	/^void CurrentDef_1(struct tree_node* p)$/;"	f
CurrentExp	Seman.c	/^Type CurrentExp(struct tree_node* p)$/;"	f
CurrentExtDecList	Seman.c	/^void CurrentExtDecList(Type inh , struct tree_node* p)$/;"	f
CurrentExtDef	Seman.c	/^void CurrentExtDef(struct tree_node* p)$/;"	f
CurrentExtDefList	Seman.c	/^void CurrentExtDefList(struct tree_node* p)$/;"	f
CurrentFunDec	Seman.c	/^int CurrentFunDec(Type inh ,struct tree_node* p)$/;"	f
CurrentOptTag	Seman.c	/^char* CurrentOptTag(struct tree_node* p)$/;"	f
CurrentParamDec	Seman.c	/^Type CurrentParamDec(struct tree_node* p)$/;"	f
CurrentProgram	Seman.c	/^void CurrentProgram(struct tree_node* p)$/;"	f
CurrentReturnExp	Seman.c	/^void CurrentReturnExp(Type return_type , struct tree_node* p)$/;"	f
CurrentSpecifier	Seman.c	/^Type CurrentSpecifier(struct tree_node* p)$/;"	f
CurrentStmt	Seman.c	/^void CurrentStmt(Type type , struct tree_node* p)$/;"	f
CurrentStmtList	Seman.c	/^void CurrentStmtList(Type type , struct tree_node* p)$/;"	f
CurrentStructSpecifier	Seman.c	/^Type CurrentStructSpecifier(struct tree_node* p)$/;"	f
CurrentTag	Seman.c	/^char* CurrentTag(struct tree_node* p)$/;"	f
CurrentVarDec	Seman.c	/^FieldList CurrentVarDec(Type inh , struct tree_node* p)$/;"	f
CurrentVarDec_1	Seman.c	/^FieldList CurrentVarDec_1(Type inh , struct tree_node* p)$/;"	f
CurrentVarList	Seman.c	/^FieldList CurrentVarList(struct tree_node* p , int* para_amount)$/;"	f
DEC	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
DIV	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
Dec	syntax.y	/^Dec : VarDec {$$ = creat_node(1 , "Dec" , &@$ ,  $1);}$/;"	l
DecList	syntax.y	/^DecList : Dec {$$ = creat_node(1 , "DecList" , &@$ , $1);}$/;"	l
Def	syntax.y	/^Def : Specifier DecList SEMI {$$ = creat_node(3 , "Def" , &@$ ,  $1 , $2 , $3);}$/;"	l
DefList	syntax.y	/^DefList : Def DefList {$$ = creat_node(2 , "DefList" , &@$ ,  $1 , $2);}$/;"	l
Exp	syntax.y	/^Exp : Exp ASSIGNOP Exp {$$ = creat_node(3 , "Exp" , &@$ ,  $1 , $2 , $3);}$/;"	l
ExtDecList	syntax.y	/^ExtDecList : VarDec {$$ = creat_node(1 , "ExtDecList" , &@$ ,  $1);}$/;"	l
ExtDef	syntax.y	/^ExtDef : Specifier ExtDecList SEMI {$$ = creat_node(3 , "ExtDef" , &@$ ,  $1 , $2 , $3);}$/;"	l
ExtDefList	syntax.y	/^ExtDefList : ExtDef ExtDefList {$$ = creat_node(2 , "ExtDefList" , &@$ ,  $1 , $2);}$/;"	l
FALSE	Seman.h	/^enum Bool {FALSE , TRUE};$/;"	e	enum:Bool
FLEX	Makefile	/^FLEX = flex$/;"	m
FUNC	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC , RELOP , READ_ADDRESS} kind;$/;"	e	enum:Operand_::__anon4
FUNCTION	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
FieldList	Seman.h	/^typedef struct FieldList_* FieldList;$/;"	t	typeref:struct:FieldList_
FieldList_	Seman.h	/^struct FieldList_$/;"	s
FindFunc	FuncTable.c	/^int FindFunc(char* name)$/;"	f
FindId	IdTable.c	/^Type FindId(char* name)$/;"	f
FindStruct	StructTable.c	/^FieldList FindStruct(char* name)$/;"	f
FunDec	syntax.y	/^FunDec : ID LP VarList RP {$$ = creat_node(4 , "FunDec" , &@$ ,  $1 , $2 , $3 , $4);}$/;"	l
FuncTable	FuncTable.h	/^struct CharactInfoEntry_Func FuncTable[10];$/;"	v	typeref:struct:CharactInfoEntry_Func
GOTO	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
IdTable	IdTable.h	/^struct CharactInfoEntry_Id IdTable[100];$/;"	v	typeref:struct:CharactInfoEntry_Id
Id_name	IdTable.h	/^	char* Id_name;$/;"	m	struct:CharactInfoEntry_Id
InterCode	translate.h	/^struct InterCode$/;"	s
InterCodes	translate.h	/^struct InterCodes$/;"	s
IsHomoStruct	StructTable.c	/^bool IsHomoStruct(FieldList target , FieldList origin)$/;"	f
IsHomoType	StructTable.c	/^bool IsHomoType(Type target , Type origin)$/;"	f
IsLeft	Seman.c	/^bool IsLeft(struct tree_node* p)$/;"	f
IsSameFuncName	FuncTable.c	/^bool IsSameFuncName(char* name)$/;"	f
IsSameInStruct	StructTable.c	/^bool IsSameInStruct(FieldList origin , char* name)$/;"	f
IsSameName	Seman.c	/^bool IsSameName(char* name)$/;"	f
IsSameNameInField	Seman.c	/^bool IsSameNameInField(FieldList field , char* name)$/;"	f
IsSameNameInStructure	Seman.c	/^void IsSameNameInStructure(FieldList field)$/;"	f
IsSameStructure	Seman.c	/^bool IsSameStructure(FieldList target , FieldList origin)$/;"	f
IsSameType	Seman.c	/^bool IsSameType(Type target , Type origin)$/;"	f
LABEL	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
LABEL_SIGN	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC , RELOP , READ_ADDRESS} kind;$/;"	e	enum:Operand_::__anon4
LFC	Makefile	/^LFC = $(shell find .\/ -name "*.l" | sed s\/[^\/]*\\\\.l\/lex.yy.c\/)$/;"	m
LFILE	Makefile	/^LFILE = $(shell find .\/ -name "*.l")$/;"	m
LFO	Makefile	/^LFO = $(LFC:.c=.o)$/;"	m
MUL	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
OBJS	Makefile	/^OBJS = $(CFILES:.c=.o)$/;"	m
Operand	translate.h	/^typedef struct Operand_* Operand;$/;"	t	typeref:struct:Operand_
Operand_	translate.h	/^struct Operand_$/;"	s
Operand_in_reg	genasm.h	/^struct Operand_in_reg$/;"	s
Operand_in_reg	genasm.h	/^typedef struct Operand_in_reg* Operand_in_reg;$/;"	t	typeref:struct:Operand_in_reg
OptTag	syntax.y	/^OptTag : ID {$$ = creat_node(1 , "OptTag" , &@$ ,  $1);}$/;"	l
PARAM	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
ParamDec	syntax.y	/^ParamDec : Specifier VarDec {$$ = creat_node(2 , "ParamDec" , &@$ ,  $1 , $2);}$/;"	l
Program	syntax.y	/^Program : ExtDefList {$$ = creat_node(1 , "Program" , &@$ ,  $1); root = $$;}$/;"	l
READ	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
READ_ADDRESS	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC , RELOP , READ_ADDRESS} kind;$/;"	e	enum:Operand_::__anon4
REF_ASSIGN	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
RELOP	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC , RELOP , READ_ADDRESS} kind;$/;"	e	enum:Operand_::__anon4
RELOP_GOTO	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
RETURN	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
Reg	genasm.h	/^struct Reg$/;"	s
STRUCT	Seman.h	/^	enum{BASIC , ARRAY , STRUCT} kind;$/;"	e	enum:Type_::__anon1
SUB	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
Seman_analysis	Seman.c	/^void Seman_analysis(struct tree_node* p)$/;"	f
Specifier	syntax.y	/^Specifier : TYPE {$$ = creat_node(1 , "Specifier" , &@$ ,  $1);}$/;"	l
Stmt	syntax.y	/^Stmt : Exp SEMI {$$ = creat_node(2 , "Stmt" , &@$ ,  $1 , $2);}$/;"	l
StmtList	syntax.y	/^StmtList : Stmt StmtList {$$ = creat_node(2 , "StmtList" , &@$ ,  $1 , $2);}$/;"	l
StructSpecifier	syntax.y	/^StructSpecifier : STRUCT OptTag LC DefList RC {$$ = creat_node(5 , "StructSpecifier" , &@$ ,  $1 , $2 , $3 , $4 , $5);}$/;"	l
StructTable	StructTable.h	/^struct CharactInfoEntry_Struct StructTable[100];$/;"	v	typeref:struct:CharactInfoEntry_Struct
Struct_name	StructTable.h	/^	char* Struct_name;$/;"	m	struct:CharactInfoEntry_Struct
TEMP	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC , RELOP , READ_ADDRESS} kind;$/;"	e	enum:Operand_::__anon4
TRUE	Seman.h	/^enum Bool {FALSE , TRUE};$/;"	e	enum:Bool
Tag	syntax.y	/^Tag : ID {$$ = creat_node(1 , "Tag" , &@$ ,  $1);}$/;"	l
Type	Seman.h	/^typedef struct Type_* Type;$/;"	t	typeref:struct:Type_
Type_	Seman.h	/^struct Type_$/;"	s
VARIABLE	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC , RELOP , READ_ADDRESS} kind;$/;"	e	enum:Operand_::__anon4
VarDec	syntax.y	/^VarDec : ID {$$ = creat_node(1 , "VarDec" , &@$ ,  $1);}$/;"	l
VarList	syntax.y	/^VarList : ParamDec COMMA VarList {$$ = creat_node(3 , "VarList" , &@$ ,  $1 , $2 , $3);}$/;"	l
WRITE	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	e	enum:InterCode::__anon6
WriteFuncTable	FuncTable.c	/^int WriteFuncTable(char* name , Type return_type , int para_amount , FieldList parameter)$/;"	f
WriteIdTable	IdTable.c	/^void WriteIdTable(Type inh , char* name)$/;"	f
WriteStructTable	StructTable.c	/^void WriteStructTable(FieldList p , char* name)$/;"	f
YFC	Makefile	/^YFC = $(shell find .\/ -name "*.y" | sed s\/[^\/]*\\\\.y\/syntax.tab.c\/)$/;"	m
YFILE	Makefile	/^YFILE = $(shell find .\/ -name "*.y")$/;"	m
YFO	Makefile	/^YFO = $(YFC:.c=.o)$/;"	m
__COMMON__	common.h	6;"	d
__FUNC__	FuncTable.h	4;"	d
__GEN__	genasm.h	2;"	d
__ID__	IdTable.h	4;"	d
__OPT__	optimize.h	2;"	d
__SEMAN__	Seman.h	2;"	d
__STRUCT__	StructTable.h	3;"	d
__TRAN__	translate.h	2;"	d
_prompt	out.s	/^_prompt: .asciiz "Enter an integer:"$/;"	l
_ret	out.s	/^_ret: .asciiz "\\n"$/;"	l
alop	translate.h	/^		struct {Operand x, y, z;} alop;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon10
arg	translate.h	/^		struct {Operand x;} arg;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon16
array	Seman.h	/^		struct{Type elem; int size;}array;$/;"	m	union:Type_::__anon2	typeref:struct:Type_::__anon2::__anon3
assignop	translate.h	/^		struct {Operand x , y;} assignop;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon11
basic	Seman.h	/^		int basic;\/\/if Int basic = 0 , if Float basic = 1$/;"	m	union:Type_::__anon2
basic_block	optimize.h	/^struct basic_block$/;"	s
basic_block_head	optimize.h	/^struct basic_block* basic_block_head;$/;"	v	typeref:struct:basic_block
begin	optimize.h	/^	struct InterCodes* begin;$/;"	m	struct:basic_block	typeref:struct:basic_block::InterCodes
bool	Seman.h	/^typedef enum Bool bool;$/;"	t	typeref:enum:Bool
callfunc	translate.h	/^		struct {Operand x , f;} callfunc;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon17
change_relop	optimize.c	/^int change_relop(int origin)$/;"	f
children	common.h	/^	struct tree_node** children;$/;"	m	struct:tree_node	typeref:struct:tree_node::tree_node
children_num	common.h	/^	unsigned int children_num;$/;"	m	struct:tree_node
code	translate.h	/^	struct InterCode code;$/;"	m	struct:InterCodes	typeref:struct:InterCodes::InterCode
code_head	translate.h	/^struct InterCodes* code_head;$/;"	v	typeref:struct:InterCodes
common_output	genasm.c	/^void common_output(FILE* des)$/;"	f
creat_node	main.c	/^struct tree_node* creat_node(int arity , char* token_name , struct YYLTYPE* current_pos, ...)$/;"	f
current_basic_block	optimize.h	/^struct basic_block* current_basic_block;$/;"	v	typeref:struct:basic_block
current_code	translate.h	/^struct InterCodes* current_code;$/;"	v	typeref:struct:InterCodes
dec	translate.h	/^		struct {Operand x ; int size;} dec;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon15
dec_process	genasm.c	/^void dec_process(FILE* des)$/;"	f
deletecode	optimize.c	/^void deletecode(struct InterCodes* code)$/;"	f
display_float	main.c	/^void display_float(char* p)$/;"	f
display_tree	main.c	/^void display_tree(struct tree_node* p , int count)$/;"	f
distroy_tree	main.c	/^void distroy_tree(struct tree_node* p )$/;"	f
do_level2_optimize	optimize.c	/^void do_level2_optimize(struct basic_block* current)$/;"	f
elem	Seman.h	/^		struct{Type elem; int size;}array;$/;"	m	struct:Type_::__anon2::__anon3
end	optimize.h	/^	struct InterCodes* end;$/;"	m	struct:basic_block	typeref:struct:basic_block::InterCodes
entry	StructTable.h	/^	FieldList entry;$/;"	m	struct:CharactInfoEntry_Struct
f	translate.h	/^		struct {Operand f;} function;$/;"	m	struct:InterCode::__anon7::__anon9
f	translate.h	/^		struct {Operand x , f;} callfunc;$/;"	m	struct:InterCode::__anon7::__anon17
func_name	FuncTable.h	/^	char* func_name;$/;"	m	struct:CharactInfoEntry_Func
func_name	translate.h	/^		char* func_name;$/;"	m	union:Operand_::__anon5
function	translate.h	/^		struct {Operand f;} function;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon9
gen_asm	genasm.c	/^void gen_asm(FILE* des)$/;"	f
get_basic_block	optimize.c	/^void get_basic_block()$/;"	f
get_reg	genasm.c	/^int get_reg(Operand op , FILE* des)\/\/op可能是一个变量，临时变量或者地址或者要读取地址中的内容$/;"	f
get_relop	translate.c	/^int get_relop(struct tree_node* p )$/;"	f
get_size_structure	translate.c	/^int get_size_structure(FieldList fieldlist)$/;"	f
get_size_type	translate.c	/^int get_size_type(Type type)$/;"	f
gotolabel	translate.h	/^		struct {Operand x;} gotolabel;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon12
head	genasm.h	/^	Operand_in_reg head;$/;"	m	struct:Reg
init_regfile	genasm.c	/^void init_regfile()$/;"	f
initial_InterCodes	translate.c	/^void initial_InterCodes()$/;"	f
initial_basic_block	optimize.c	/^void initial_basic_block()$/;"	f
insert_basic_block	optimize.c	/^void insert_basic_block(struct InterCodes* begin , struct InterCodes* end)$/;"	f
insertcode	translate.c	/^void insertcode(struct InterCodes* new_code)$/;"	f
is_label_in_use	optimize.c	/^int is_label_in_use(Operand op)$/;"	f
is_used_operand	optimize.c	/^int is_used_operand(Operand x , Operand y)$/;"	f
is_used_operand1	optimize.c	/^int is_used_operand1(struct InterCodes* current_code , struct InterCodes* end , Operand x)$/;"	f
kind	Seman.h	/^	enum{BASIC , ARRAY , STRUCT} kind;$/;"	m	struct:Type_	typeref:enum:Type_::__anon1
kind	translate.h	/^	enum {LABEL , FUNCTION , ASSIGN , ADD , SUB , MUL , DIV , ADD_ASSIGN , REF_ASSIGN , ASSIGN_REF , GOTO , RELOP_GOTO  , RETURN , DEC , ARG , CALLFUNC , PARAM , READ , WRITE } kind;$/;"	m	struct:InterCode	typeref:enum:InterCode::__anon6
kind	translate.h	/^	enum {VARIABLE , CONSTANT , TEMP , ADDRESS , LABEL_SIGN , FUNC , RELOP , READ_ADDRESS} kind;$/;"	m	struct:Operand_	typeref:enum:Operand_::__anon4
label	translate.h	/^		struct {Operand x;} label;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon8
label10	out.s	/^label10:$/;"	l
label11	out.s	/^label11:$/;"	l
label12	out.s	/^label12:$/;"	l
label14	out.s	/^label14:$/;"	l
label16	out.s	/^label16:$/;"	l
label2	out.s	/^label2:$/;"	l
label3	out.s	/^label3:$/;"	l
label4	out.s	/^label4:$/;"	l
label6	out.s	/^label6:$/;"	l
label8	out.s	/^label8:$/;"	l
label_no	translate.h	/^		int label_no;$/;"	m	union:Operand_::__anon5
label_num	translate.h	/^int label_num;$/;"	v
lineno	Seman.h	/^	int lineno;$/;"	m	struct:FieldList_
lineno	common.h	/^	int lineno;$/;"	m	struct:tree_node
lookback_arg	optimize.c	/^void lookback_arg(struct InterCodes* current_code , struct InterCodes* begin)$/;"	f
lookup_functable	FuncTable.c	/^struct CharactInfoEntry_Func* lookup_functable(char* func_name)$/;"	f
lookup_idtable	IdTable.c	/^int lookup_idtable(char* name)$/;"	f
lookup_idtable_rank	IdTable.c	/^int lookup_idtable_rank(char* name)$/;"	f
main	main.c	/^int main(int argc , char** argv)$/;"	f
main	out.s	/^main:$/;"	l
name	Seman.h	/^	char* name;$/;"	m	struct:FieldList_
next	Seman.h	/^	FieldList next;$/;"	m	struct:FieldList_
next	genasm.h	/^	Operand_in_reg next;$/;"	m	struct:Operand_in_reg
next	optimize.h	/^	struct basic_block* next;$/;"	m	struct:basic_block	typeref:struct:basic_block::basic_block
next	translate.h	/^	struct Arg* next;$/;"	m	struct:Arg	typeref:struct:Arg::Arg
next	translate.h	/^	struct InterCodes* next;$/;"	m	struct:InterCodes	typeref:struct:InterCodes::InterCodes
op	genasm.h	/^	Operand op;$/;"	m	struct:Operand_in_reg
op	translate.h	/^	Operand op;$/;"	m	struct:Arg
optimize	optimize.c	/^void optimize()$/;"	f
optimize_before_divide	optimize.c	/^void optimize_before_divide()\/\/在基本块分割之前对于一些条件判断语句做优化和无用label的消除$/;"	f
optimize_level1	optimize.c	/^void optimize_level1()$/;"	f
out_file	translate.c	6;"	d	file:
outasmadd	genasm.c	/^void outasmadd(struct InterCodes* p  , FILE* des)$/;"	f
outasmarg	genasm.c	/^void outasmarg(struct InterCodes* p  , FILE* des)$/;"	f
outasmassign	genasm.c	/^void outasmassign(struct InterCodes* p  , FILE* des)$/;"	f
outasmcallfunc	genasm.c	/^void outasmcallfunc(struct InterCodes* p  , FILE* des)$/;"	f
outasmdec	genasm.c	/^void outasmdec(struct InterCodes* p  , FILE* des)$/;"	f
outasmdiv	genasm.c	/^void outasmdiv(struct InterCodes* p  , FILE* des)$/;"	f
outasmfunc	genasm.c	/^void outasmfunc(struct InterCodes* p  , FILE* des)$/;"	f
outasmgoto	genasm.c	/^void outasmgoto(struct InterCodes* p  , FILE* des)$/;"	f
outasmlabel	genasm.c	/^void outasmlabel(struct InterCodes* p  , FILE* des)$/;"	f
outasmmul	genasm.c	/^void outasmmul(struct InterCodes* p  , FILE* des)$/;"	f
outasmparam	genasm.c	/^void outasmparam(struct InterCodes* p  , FILE* des)$/;"	f
outasmread	genasm.c	/^void outasmread(struct InterCodes* p  , FILE* des)$/;"	f
outasmrelopgoto	genasm.c	/^void outasmrelopgoto(struct InterCodes* p  , FILE* des)$/;"	f
outasmreturn	genasm.c	/^void outasmreturn(struct InterCodes* p  , FILE* des)$/;"	f
outasmsub	genasm.c	/^void outasmsub(struct InterCodes* p  , FILE* des)$/;"	f
outasmwrite	genasm.c	/^void outasmwrite(struct InterCodes* p  , FILE* des)$/;"	f
outputInterCode	translate.c	/^void outputInterCode()$/;"	f
output_relop	translate.c	/^void output_relop(Operand op1 , FILE* des)$/;"	f
outputalop	translate.c	/^void outputalop(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputarg	translate.c	/^void outputarg(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputassign	translate.c	/^void outputassign(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputcallfunc	translate.c	/^void outputcallfunc(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputdec	translate.c	/^void outputdec(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputfunction	translate.c	/^void outputfunction(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputgoto	translate.c	/^void outputgoto(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputlabel	translate.c	/^void outputlabel(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputoperand	translate.c	/^void outputoperand(Operand op , FILE* des)$/;"	f
outputparam	translate.c	/^void outputparam(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputread	translate.c	/^void outputread(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputrelopgoto	translate.c	/^void outputrelopgoto(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputreturn	translate.c	/^void outputreturn(struct InterCodes* intercode_p , FILE* des)$/;"	f
outputwrite	translate.c	/^void outputwrite(struct InterCodes* intercode_p , FILE* des)$/;"	f
para_amount	FuncTable.h	/^	int para_amount;$/;"	m	struct:CharactInfoEntry_Func
param	translate.h	/^		struct {Operand x;} param;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon18
param_or_not	IdTable.h	/^	int param_or_not;\/\/ 1 means is param$/;"	m	struct:CharactInfoEntry_Id
parameter	FuncTable.h	/^	FieldList parameter;$/;"	m	struct:CharactInfoEntry_Func
pre_occupy_func	translate.c	/^void pre_occupy_func()$/;"	f
prev	optimize.h	/^	struct basic_block* prev;$/;"	m	struct:basic_block	typeref:struct:basic_block::basic_block
prev	translate.h	/^	struct InterCodes* prev;$/;"	m	struct:InterCodes	typeref:struct:InterCodes::InterCodes
read	out.s	/^read:$/;"	l
read	translate.h	/^		struct {Operand x;} read;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon19
reg_a	genasm.h	/^struct Reg reg_a[4];	\/\/for parameters$/;"	v	typeref:struct:Reg
reg_s	genasm.h	/^struct Reg reg_s[9];	\/\/use freely belong to callee$/;"	v	typeref:struct:Reg
reg_t	genasm.h	/^struct Reg reg_t[10];	\/\/use freely belong to caller$/;"	v	typeref:struct:Reg
reg_v	genasm.h	/^struct Reg reg_v[2];	\/\/for return value$/;"	v	typeref:struct:Reg
relop	translate.h	/^		int relop;$/;"	m	union:Operand_::__anon5
relop	translate.h	/^		struct {Operand x, y, z , relop;} relopgoto;$/;"	m	struct:InterCode::__anon7::__anon13
relopgoto	translate.h	/^		struct {Operand x, y, z , relop;} relopgoto;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon13
ret	translate.h	/^		struct {Operand x;} ret;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon14
return_type	FuncTable.h	/^	Type return_type;$/;"	m	struct:CharactInfoEntry_Func
root	main.c	/^struct tree_node* root;$/;"	v	typeref:struct:tree_node
separate	out.s	/^separate:$/;"	l
size	Seman.h	/^		struct{Type elem; int size;}array;$/;"	m	struct:Type_::__anon2::__anon3
size	translate.h	/^		struct {Operand x ; int size;} dec;$/;"	m	struct:InterCode::__anon7::__anon15
structure	Seman.h	/^		FieldList structure;$/;"	m	union:Type_::__anon2
temp_no	translate.h	/^		int temp_no;$/;"	m	union:Operand_::__anon5
temp_num	translate.h	/^int temp_num;$/;"	v
token_name	common.h	/^	char* token_name;$/;"	m	struct:tree_node
translate	translate.c	/^void translate(struct tree_node* p)$/;"	f
translate_args	translate.c	/^void translate_args(struct tree_node* p , struct Arg** arg_list)$/;"	f
translate_compst	translate.c	/^void translate_compst(struct tree_node* p)\/\/LC DefList StmtList RC$/;"	f
translate_cond	translate.c	/^void translate_cond(struct tree_node* p , Operand label_true , Operand label_false)$/;"	f
translate_dec	translate.c	/^void translate_dec(struct tree_node* p)$/;"	f
translate_declist	translate.c	/^void translate_declist(struct tree_node* p)$/;"	f
translate_def	translate.c	/^void translate_def(struct tree_node* p)$/;"	f
translate_deflist	translate.c	/^void translate_deflist(struct tree_node* p)$/;"	f
translate_exp	translate.c	/^void translate_exp(struct tree_node* p , Operand place)$/;"	f
translate_exp_dot_id	translate.c	/^FieldList translate_exp_dot_id(struct tree_node* p , Operand place)$/;"	f
translate_function	translate.c	/^void translate_function(struct tree_node* p)\/\/FunDec->ID LP VarList RP$/;"	f
translate_paramdec	translate.c	/^void translate_paramdec(struct tree_node* p)$/;"	f
translate_stmt	translate.c	/^void translate_stmt(struct tree_node* p)$/;"	f
translate_stmtlist	translate.c	/^void translate_stmtlist(struct tree_node* p)$/;"	f
translate_vardec	translate.c	/^void translate_vardec(struct tree_node* p)\/\/only used in paramdec$/;"	f
translate_varlist	translate.c	/^void translate_varlist(struct tree_node* p)$/;"	f
tree_node	common.h	/^struct tree_node$/;"	s
try_to_delete_death	optimize.c	/^struct InterCodes* try_to_delete_death(struct InterCodes* current_code , struct InterCodes* end)\/\/消除死代码$/;"	f
type	IdTable.h	/^	Type type;$/;"	m	struct:CharactInfoEntry_Id
type	Seman.h	/^	Type type;$/;"	m	struct:FieldList_
type	common.h	/^	int type;\/*1:INT FLOAT TYPE ID 2:lexical 3:bison*\/$/;"	m	struct:tree_node
u	Seman.h	/^	}u;$/;"	m	struct:Type_	typeref:union:Type_::__anon2
u	translate.h	/^	}u;$/;"	m	struct:InterCode	typeref:union:InterCode::__anon7
u	translate.h	/^	}u;$/;"	m	struct:Operand_	typeref:union:Operand_::__anon5
unit_name	common.h	/^	char* unit_name;$/;"	m	struct:tree_node
v3	out.s	/^v3: .space 12$/;"	l
valid	FuncTable.h	/^	int valid;$/;"	m	struct:CharactInfoEntry_Func
valid	IdTable.h	/^	int valid;$/;"	m	struct:CharactInfoEntry_Id
valid	StructTable.h	/^	int valid;$/;"	m	struct:CharactInfoEntry_Struct
value	translate.h	/^		int value;$/;"	m	union:Operand_::__anon5
var_no	IdTable.h	/^	int var_no;$/;"	m	struct:CharactInfoEntry_Id
var_no	translate.h	/^		int var_no;$/;"	m	union:Operand_::__anon5
variable_num	translate.h	/^int variable_num;$/;"	v
write	out.s	/^write:$/;"	l
write	translate.h	/^		struct {Operand x;} write;$/;"	m	union:InterCode::__anon7	typeref:struct:InterCode::__anon7::__anon20
x	translate.h	/^		struct {Operand x , f;} callfunc;$/;"	m	struct:InterCode::__anon7::__anon17
x	translate.h	/^		struct {Operand x , y;} assignop;$/;"	m	struct:InterCode::__anon7::__anon11
x	translate.h	/^		struct {Operand x ; int size;} dec;$/;"	m	struct:InterCode::__anon7::__anon15
x	translate.h	/^		struct {Operand x, y, z , relop;} relopgoto;$/;"	m	struct:InterCode::__anon7::__anon13
x	translate.h	/^		struct {Operand x, y, z;} alop;$/;"	m	struct:InterCode::__anon7::__anon10
x	translate.h	/^		struct {Operand x;} arg;$/;"	m	struct:InterCode::__anon7::__anon16
x	translate.h	/^		struct {Operand x;} gotolabel;$/;"	m	struct:InterCode::__anon7::__anon12
x	translate.h	/^		struct {Operand x;} label;$/;"	m	struct:InterCode::__anon7::__anon8
x	translate.h	/^		struct {Operand x;} param;$/;"	m	struct:InterCode::__anon7::__anon18
x	translate.h	/^		struct {Operand x;} read;$/;"	m	struct:InterCode::__anon7::__anon19
x	translate.h	/^		struct {Operand x;} ret;$/;"	m	struct:InterCode::__anon7::__anon14
x	translate.h	/^		struct {Operand x;} write;$/;"	m	struct:InterCode::__anon7::__anon20
y	translate.h	/^		struct {Operand x , y;} assignop;$/;"	m	struct:InterCode::__anon7::__anon11
y	translate.h	/^		struct {Operand x, y, z , relop;} relopgoto;$/;"	m	struct:InterCode::__anon7::__anon13
y	translate.h	/^		struct {Operand x, y, z;} alop;$/;"	m	struct:InterCode::__anon7::__anon10
z	translate.h	/^		struct {Operand x, y, z , relop;} relopgoto;$/;"	m	struct:InterCode::__anon7::__anon13
z	translate.h	/^		struct {Operand x, y, z;} alop;$/;"	m	struct:InterCode::__anon7::__anon10
